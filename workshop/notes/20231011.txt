JPA 페이지네이션 구현
    Repository 구현체에 PageRequest 객체를 전달함으로써 DB에 독립적이게 페이지 조회가 가능해짐
    PageRequest 객체를 전달할 경우 Page<T> 객체가 반환됨
        Page<T> 객체에는 map 함수가 존재하며, 이러한 함수들로 추가적인 변환이 가능함
        Page<T> 객체에는 toList() 함수가 있어서, 바로 변환이 가능함

    예시
        PageRequest.of(pageNumber, pageSize, Sort.by(Sort.Direction.ASC, "id"));
            pageNumber - 페이지를 나누기 위해서. 0부터 시작함
            pageSize - 각 페이제에서 표시되는 원소들의 총 개수를 전달하기 위해서
            Sort.by - 특정 원소를 기준으로 정렬되어서 반환시킬 수 있음

컨트롤러에서 파라미터 얻기
    컨트롤러의 각 메소드의 변수 앞에 어노테이션을 추가시켜서 값을 얻을 수 있음
        @RequestBody - HTTP BODY에 전달된 JSON 형태의 데이터를 파싱하고, 받기 위해서
        @PathVariable - URL에 전달된 데이터 값을 파싱하고, 받기 위해서
        @RequestParam - URL의 ? 뒤에 전달되는 쿼리 값을 파싱하기 위해서
    
    예시: @RequestParam 활용하기
        @GetMapping("/add")
        public ResponseEntity<Integer> add(@RequestParam("num1") int num1, @RequestParam("num2") int num2)
            RequestParam 어노테이션에 받을 변수이름을 넣어서 그 값을 어노테이션된 파라미터에 저장시킴
        
    @RequestParam을 Dto에서 활용하기(https://e-room.tistory.com/169)
        어노테이션을 사용하지 않거나, @ModelAttribute 어노테이션을 사용해서 Dto로 사용할 객체를 전달해주기만 하면 된다.
            되도록이면 어노테이션을 사용하는 편이 좋다.

        디폴트 값 처리하기
            Dto 초기화시에 @Builder를 사용하지 않기때문에 @Builder.Default 어노테이션을 활용할 수 없다.
            기본적으로 AllArgesConstructor을 활용하기 때문에 여기에 디폴트 값을 적용하거나,
            @Data 형태로 선언뒤, 디폴트 값을 기본값으로 넣어 줄 수 있다.

Dto 객체 개선
    @Builder 보다는 생성자에서 특정 객체에 맞게 초기화후에, @Getter만 제공하는게 더 접근성 관리나 유지보수 측면에서 효율적인 것 같음
    HTTP 요청, 응답시에는 항상 Dto 객체를 주고 받으므로, 이를 reqDto, resDto로 명칭할 수 있음

    reqDto는 자동으로 전달되므로, @Getter, @RequiredArgsConstructor 어노테이션만 제공하면됨
    resDto는 @Getter 및 수동으로 생성자를 만들어줌

접근 허용 패턴에 Regex 사용하기
    antMatchers() 대신에 regexMatchers()를 사용해서, 정규식을 이용해서 더 복잡한 경로에 대한 허용 룰을 적용할 수 있음

    예시
        .regexMatchers(HttpMethod.GET, "^\\/problems\\/[0-9]+$").permitAll()
            '/'는 '\\/'로 파싱해줘야 함에 유의함
            '^'로 시작해서 '$'로 끝나도록 정규식을 static하게 만드는게 좋음